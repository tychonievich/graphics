---
title: Commonly-used `gl.`functions
summary: With an informal description of what each one does.
header-includes: |
    <style>
    div > dl > dt { clear: inherit; }
    .header-section-number, .toc-section-number { display: none; }
    </style>
...

The following are presented in order of frequency of use in roughly 200 student's submissions of 4 WebGL2 assignments.


# `gl.getUniformLocation`

Given
:   a compiled GLSL program and the name of a `uniform` variable in one or both of those shaders.

Returns
:   an integer, indicating which uniform slot that uniform is in.

Notes
:   Uniforms are generally data sent from the CPU to the GPU once and accessed by all the vertices and/or fragments in the scene.
    They are commonly used for matrices, textures, and some scene-wide constants like light locations.
    
    Each uniform is given a specific location, a small integer usually between 0 and 15.
    The shader linker picks these locations per program, and may pick different locations each compilation.

Common errors
:   Because the location is a small integer, using the wrong one
    (such as the location of a similarly-named uniform from a different shader program)
    might work sometimes and then fail later.
    Make sure you use the correct program and uniform name.


# `gl.bindVertexArray`

Given
:   The return value of [`gl.createVertexArray`], a Vertex Array Object (VAO).

Side effects
:   Two related effects.

    First, the VAO will record all subsequent calls of

    - [`gl.bindBuffer`]
    - [`gl.vertexAttribPointer`]

    and a few related but uncommon functions.

    Second, at the moment of binding, anything recorded by the previously-bound VAO (which may be a default VAO managed by WebGL2 if none was ever bound)
    will be disabled and anything previously recorded by this VAO will be re-enabled.

Common errors
:   The VAO can span multiple shader programs,
    but only if the attribute locations passed into [`gl.vertexAttribPointer`]
    are manually specified, not generated by the compiler.


# `gl.useProgram`

Given
:   A compiled and linked shader program.

Side effects
:   Future rendering calls will run with this shader program,
    potentially changing both view (via vertex shader) and appearance (via fragment shader).


# `gl.clear`

Given
:   A bit-mask indicating a set of display buffers; most often, `gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT`{.js}

Side effects
:   Erases the indicated display buffers,
    either to the default value (transparent black for color, 1 for depth)
    or to a different value previously set by corresponding configuration function.


# `gl.uniformMatrix4fv`

Given
:   1.  The return value of [`gl.getUniformLocation`], which is a shader program-specific integer
    2.  `false`{.js} (no other value permitted)
    3.  An array or `Float32Array` containing 16 numbers

Side effects
:   Sets the value of a `uniform mat4`{.glsl} in the GPU.

Common errors
:   WebGL2 assumes arrays are given in *column-major order*; that is,

    ````js
    gl.uniformMatrix4fv(loc, false,
        [ 1,  2,  3,  4
        , 5,  6,  7,  8
        , 9, 10, 11, 12
        ,13, 14, 15, 16
        ])
    ````

    will create the matrix $$\begin{bmatrix}1&5&9&13\\2&6&10&14\\3&7&11&15\\4&8&12&16\end{bmatrix}$$
    which is not the order that most programmers expect.


# `gl.bindBuffer`

Given
:   1. A bind point, typically either `gl.ARRAY_BUFFER` (for attributes) or `gl.ELEMENT_ARRAY_BUFFER` (for indices)
    2. The return value of [`gl.createBuffer`], an opaque pointer to an array in GPU memory

Side effects
:   Links the bind point to the buffer.
    Because almost all buffer-modifying calls operate on bind points, not buffer objects, this is a necessary initial step in many GPU-memory-influencing operations.

Notes
:   Buffers to *not* depend on shader program and can be shared across as many programs as use the same data.

Common errors
:   Because buffers remain bound until a different buffer is bound to the same bind point,
    forgetting to call `gl.bindBuffer` might accidentally work if the correct buffer was the last one bound,
    but then stop working if you later change setup code or the like.
    To avoid this problem, it is recommended that any JavaScript function that interacts with a buffer
    calls `gl.bindBuffer` before doing so.


# `gl.bufferData`

Given
:   1. A bind point (see [`gl.bindBuffer`])
    2. A flat typed array, typically a `Float32Array` for attributes or `Uint16Array` for indices
    3. A usage pattern hint, typically either `gl.STATIC_DRAW` for data that will be supplied just once or `gl.DYNAMIC_DRAW` for data that will be re-supplied every frame
    4. (optionally, a range of indices of the array to include)

Side effects
:   1. Sends the bytes of the array to GPU memory
    2. Optionally, optimizes how the bytes are stored based on the usage pattern hint
    3. Changes the buffer that is currently bound to the bind point to refer to the new array
    4. Frees the array that the buffer that is currently bound to the bind point previously referred to

    In more flexible standards like Vulkan, step 4 is not guaranteed as an array might be referenced by multiple buffers,
    but that can't happen in WebGL2.
    Because step 4 is guaranteed in WebGL2, it can be moved to happen earlier in this sequence,
    often re-using memory from the old array for the new one.

Notes
:   If you know that you already have a buffer that is the right size and just want to change its contents,
    [`gl.bufferSubData`] may be faster as it does not rely on optimizations to avoid allocating more memory.


# `gl.drawElements`

Given
:   1. A primitive type, most often `gl.TRIANGLES`
    2. A count of indices the read from the currently-bound element array buffer
        which was set up via [`gl.bindBuffer`] and generally re-enabled via [`gl.bindVertexArray`]
    3. The binary data type in the currently-bound element array buffer, typically `gl.UNSIGNED_SHORT`
    4. The *byte* offset of the first index to read, typically 0

Side effects
:   Renders geometry
    with vertex data given by [`gl.vertexAttribPointer`],
    primitive connectivity set by the current `gl.ELEMENT_ARRAY_BUFFER`,
    and the shader program set by [`gl.useProgram`].

Common errors
:   The count is a count of indices, not primitives:
    if you have 10 triangles then the count needs to be 30, not 10.
    
    The offset is in bytes, not indices or primitives:
    if you want to skip the first 10 triangles
    and have `gl.UNSIGNED_SHORT` indices
    then the offset is (2 bytes per index) × (3 indices per triangle) × (10 triangles) = 60.        


# `gl.createBuffer`

Returns
:   an opaque pointer that can refer to an array in GPU memory

Notes
:   The thing returned by this function does not have a precise parallel in the CPU-only code that you'd used in other classes.
    It serves primarily as a way of managing GPU memory.
    
    Actions on buffers all requiring using [`gl.bindBuffer`] to link them to one of a fixed set of bind points.
    The buffer returned by `gl.createBuffer` is not used otherwise directly used in your code.

    Arrays allocated in GPU memory by [`gl.bufferData`] are attached to the buffer currently bound to the bind point.
    If a different array is attached to the same buffer
    or when the buffer is garbage collected by JavaScript, the array is freed.

Common errors
:   `gl.createBuffer` controls GPU memory management and should be called only as needed.
    If you want to change data, use [`gl.bufferData`] without re-calling `gl.createBuffer`;
    calling `gl.createBuffer` every frame is likely to cause a GPU memory leak.
    
    `gl.createBuffer` does not bind its return value; you'll generally want to follow it with [`gl.bindBuffer`].
    
    Buffers only store bytes.
    The data types represented by those bytes is handled by the combination of the data supply functions [`gl.bufferData`]/[`gl.bufferSubData`]
    and the data use functions [`gl.vertexAttribPointer`]/[`gl.drawElements`].
    Mixing and matching types in those calls is *very* unlikely to work.



# `gl.attachShader`

Given
:   1. the return value of [`gl.createProgram`]
    2. the return value of [`gl.createShader`], after calling [`gl.shaderSource`] and [`gl.compileShader`] on it

Side effect
:   Picks a shader to be part of a given shader program, preparatory to linking.

Notes
:   You may attach the same shader to as many shader programs as you wish.
    
    Exactly one vertex shader and one fragment shader must be attached to a shader program prior to linking.
    
    Once attached to a shader program, the shader variable is no longer needed.


# `gl.createShader`

Given
:   the type of shader, either `gl.VERTEX_SHADER` or `gl.FRAGMENT_SHADER`

Returns
:   An opaque handle to a shader, suitable to use in [`gl.shaderSource`],  [`gl.compileShader`], and [`gl.attachShader`].



# `gl.shaderSource`

Given
:   1. the return value of [`gl.createShader`]
    2. a string containing GLSL source code

Side effect
:   Sets the source code for the given shader.

Notes
:   Always followed by [`gl.compileShader`].
    `gl.shaderSource` performs no error checking or any kind;
    all that is done by [`gl.compileShader`].

Common errors
:   To use WebGL2's shader language, the GLSL source must begin (not even a space or newline before it) with the exact string `#version 300 es`.
    Without that, the shader defaults to WebGL1's shader language which had various differences in syntax and semantics and might cause errors either at compile or run time.


# `gl.compileShader`

Given
:   the return value of [`gl.createShader`], after calling [`gl.shaderSource`] on it

Side effects
:   Attempts to generate a binary suitable for being half of a shader program to run on the GPU.
    If there are errors, stores those internally instead.
    Both the compiled binary and the errors are stored inside the argument of the function, not returned.

Common errors
:   Always check the `gl.COMPILE_STATUS` using [`gl.getShaderParameter`] after running this function;
    without that you can't tell if the compilation succeeded or not.


# `gl.getShaderParameter`

Given
:   1. the return value of [`gl.createShader`]
    2. what you want to check, typically `gl.getShaderParameter`

Returns
:   One of a fixed set of values, depending on what you checked.
    For `gl.getShaderParameter`, either `true` for success or `false` for any compiler error.

Common errors
:   Always check the `gl.COMPILE_STATUS` after running [`gl.compileShader`];
    without that you can't tell if the compilation succeeded or not.
    
    If the status is `false`, use [`gl.getShaderInfoLog`] to learn why the compilation failed.


# `gl.getShaderInfoLog`

Given
:   the return value of [`gl.createShader`]

Returns
:   Any diagnostic, warning, error, or informational messages that have been associated with this shader.
    May be the empty string if there are not such messages.

Common errors
:   `gl.getShaderInfoLog` does not remove the need for [`gl.getShaderParameter`]:
    the info log might be non-empty even if the compilation succeeds.


# `gl.uniform1f`

Given
:   1.  The return value of [`gl.getUniformLocation`], which is a shader program-specific integer
    2.  A number

Side effects
:   Sets the value of a `uniform float`{.glsl} in the GPU.

Common errors
:   WebGL2 allows you to have a mismatch between provided data and shader data size,
    such as using `gl.uniform1f` to set a `vec4`,
    but doing so tends to cause confusion and errors and should be avoided.


# `gl.clearColor`

Given
:   four numbers between 0 and 1 (RGBA)

Side effect
:   Sets the color that subsequent [`gl.clear`] will replace the entire canvas with, assuming `gl.COLOR_BUFFER_BIT` is included in the `gl.clear` call.

Note
:   If the fourth value (alpha) is less than 1, the canvas will be cleared with a (partially) transparent color,
    allowing whatever is behind the canvas on the webpage to be visible through it (until you draw something over it, of course).


# `gl.enableVertexAttribArray`

Given
:   the location of an attribute, as given by `layout(location=...)` in the vertex shader

Side effect
:   Informs the GPU that you plan to use this attribute, allowing subsequent functions to refer to it.

Common errors
:  `gl.enableVertexAttribArray` must be called on an attribute location before it is used in any other functions.


# `gl.vertexAttribPointer`

Given
:   1. `index`: the location of an attribute, as given by `layout(location=...)` in the vertex shader
    2. `size`: an integer between 1 and 4 (inclusive), indicating how many numbers are in the array per attribute (e.g. for 2D Cartesian vectors this would be 2)
    3. `type`: a type code, describing how to parse the bytes in the array; typically `gl.FLOAT`
    4. `normalized`: whether to try to convert integers to floats or not; typically `false`, ignored if the previous argument was `gl.FLOAT`
    5. `stride`: how many bytes to skip between the end of one attribute value and the start of the next; typically `0`
    6. `offset`: the index of the first byte of the first value to reach; typically `0`

Side effect
:   Tells the GPU how to parse the byes of a buffer into numbers to send into attributes (i.e. vertex shader `in` variables).
    Note that this is connected to the attribute, not the buffer,
    to support cases where multiple attributes are stored in different parts of the same buffer.

Notes
:   The `size` argument should be the number of elements per value in the buffer, not in the vertex shader.
    For example, if you have a `vec3` in GLSL being supplied with 2-vectors in the buffer you'd use `2`, not `3`;
    the GPU will automatically fill in any missing parts of the GLSL declaration with the corresponding coordinate of the homogeneous zero point $(0,0,0,1)$.
    
    The `type` and `normalized` arguments are primarily for memory-constrained systems with very large geometries;
    they should be `gl.FLOAT` and `false`, respectively, unless you spend time learning the various other formats and how they are mapped to floats.
    
    The `stride` and `offset` arguments can be used to store several attributes in a single buffer.
    
    <div class="example">
    If I had a `Float32Array` storing position and normal interleaved as $[p_{1,x}, p_{1,y}, p_{1,z}, n_{1,x}, n_{1,y}, n_{1,z}, p_{2,x}, p_{2,y}, \dots]$
    I'd send it to the GPU using [`gl.bufferData`] and tell the GPU to parse it as
    
    ````js
    let posiLoc = /* the value from layout(location=...) in the vertex shader */
    let normLoc = /* the value from layout(location=...) in the vertex shader */
    gl.vertexAttribPointer(posiLoc, 3, gl.FLOAT, 0, 3*4, 0*4)
    gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, 0, 3*4, 3*4)
    ````
    
    where the `*4` is handling the bytes per value in a `Float32Array`.
    </div>

Common errors
:   `size` is the size of *one attribute value*, not the entire array.
    
    `size` uses the unit of "numbers", while `stride` and `offset` use the unit of "bytes".
    
    `type` must match the format of the typed array passed to [`gl.bufferData`];
    for example, `Float32Array` must be paired with `gl.FLOAT`.

   [`gl.enableVertexAttribArray`] must be called on an attribute location before it is used in any other functions, including `gl.vertexAttribPointer`.


# `gl.createProgram`



# `gl.linkProgram`



# `gl.getProgramParameter`



# `gl.getProgramInfoLog`



# `gl.createVertexArray`



# `gl.drawArrays`



# `gl.uniform4fv`



# `gl.uniform1i`



# `gl.enable`



# `gl.viewport`



# `gl.uniform3fv`



# `gl.blendFunc`



# `gl.uniform4f`



# `gl.uniform2fv`



# `gl.uniform2f`



# `gl.texParameteri`



# `gl.activeTexture`



# `gl.disable`



# `gl.uniform1fv`



# `gl.bindTexture`



# `gl.texImage2D`



# `gl.uniformMatrix3fv`



# `gl.uniform4iv`



# `gl.uniform3iv`



# `gl.uniform2iv`



# `gl.getUniform`



# `gl.generateMipmap`



# `gl.detachShader`



# `gl.createTexture`



# `gl.bufferSubData`



# `gl.vertexAttrib3f`



# `gl.validateProgram`



# `gl.uniformMatrix2fv`



# `gl.pixelStorei`



# `gl.getVertexAttrib`



# `gl.getExtension`



# `gl.getActiveUniform`



# `gl.depthFunc`



# `gl.deleteProgram`



# `gl.blendEquation`


