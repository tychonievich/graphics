---
title: Readings for CS 418
...

1. Introductory material
    
    These include some overviews that put other topics in context
    and some cross-cutting concerns that reappear frequently in other areas.
    
    a. <api-types.md>
    a. <aliasing.md>
    a. <overview.md>
    a. <obselete.md>
    a. <color.md>
    a. optional enrichment:
        i. <two-paths.md>

    At the end of this section you should be able to
    
    - categorize graphics APIs by what they manage
    - identify problems with both point- and area-based pixels
    - list the 5 steps of the rasterizing graphics pipeline
    - given a graphics task, identify which pipeline steps it would use
    - describe the difference between LMS, RGB, and Y'CbCr color spaces
    - apply gamma correction in both directions, and identify when each direction should be applied
    
2. Rasterization
    
    This content teaches you what the GPU is doing and prepares you to implement that same functionality on the CPU.
    
    a. <fixed-functionality.md> needs to be broken into smaller pages
    a. <http://luthert.web.illinois.edu/blog/posts/492.html> may also help
    a. optional enrichment:
        i. <implicit-curves.md>
        i. <finite-differences.md>
    
    
    At the end of this section you should be able to
    
    - understand all parts of the GPU's fixed functionality well enough to implement it in any language

3. WebGL2
    
    This section contains guides and tips for effective use of the GPU via the WebGL2 API implemented by almost all web browsers.
    
    a. <javascript.md>
    a. <minimal-webgl.md>
    a. <cors.md>
    a. GPU warps

    At the end of this section you should be prepared for the next section.
    It has no other learning outcomes of its own.
    
4. 3D Graphics
    
    This section presents the basics of representing 3D objects, moving them, and viewing them from various angles with basic lighting.
    
    a. attribute, varying, uniform
    a. vertex array objects
    a. <math2.md>
    a. <webgl-goemetry.md>
    a. demos
    a. normals
    a. <lighting.md>
    a. thinking in coordinate systems
    a. optional enrichment:
        i. <obj.md>

    At the end of this section you should be able to 
    
    - write efficient WebGL2 code for a 3D scene
    - position, orient, size, and light objects in a 3D scene
    - move a camera through a scene in response to user input

5. Better 3D Graphics
    
    This section reviews some techniques beyond the basics that help make good-looking scenes more efficient to program.
    
    a. generating your own geometry
    a. fractals
    a. <faculting.md>
    a. normal computation
    a. <textures.md>
    a. PBR
    a. <textures2.md>
    a. <quaternions.md>
    a. <keyframe.md>
    a. <bezier.md>
    a. optional enrichment:
        i. <erosion.md>
        i. <deferred.md>
        i. <shadowmap.md> -- add more about aliasing
        i. subdivision surfaces
        i. parametric surfaces
        i. toon shading and outlines
    
    At the end of this section you should be able to 
    
    - generate procedural geometry, including fractal terrain
    - add smooth normals to meshes lacking them
    - interpolate smoothly between keyframes
    - use textures for all parts of fragment shading
    - identify if a lighting model is physically plausible or not

6. Raytracing
    
    This section provides a brief overview of a rendering technique that is optimized for fancy light transport instead of for single-pass rendering of full scenes.
    
    a. <rays.md>
    a. <ray-vs-rast.md>
    a. <integration.md>
    a. BVH
    a. rounding errors

    At the end of this section you should be able to
    
    - implement a basic raytracer
    - simulate direct lighting with shadows
    - simulate indirect light for Lambert, mirrored, and glassy materials
    - optimize raytracing with a bounding volume hierarchy

7. Simulation
    
    This section introduces a few ideas where the geometry and its motion is generated by approximating various heuristic and/or physically-inspired laws.
    
    a. particle effects
    a. kinematics
    a. <simulation.md>
    a. grid fluids
    a. SPH
    a. boids
    a. MPM and other hybrid methods
    
    At the end of this section you should be able to
    
    - implement collisions between spheres
    - implement heuristic fireworks-like effects
    - implement the 1987 Boids algorithm
    - describe how non-local effects are handled in particle- and grid-based simulations

